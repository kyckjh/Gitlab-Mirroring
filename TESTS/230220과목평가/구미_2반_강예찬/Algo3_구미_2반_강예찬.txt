다음과 같이 소괄호를 포함한 문자열이 있다.
    if((i==0)&&(j==0)))
(1) 스택을 이용해 괄호가 정상적으로 표시되어 있는지 검사하는 알고리즘에 대해 간단히 설명하라.

스택은 LIFO(Last-In-First-Out)인 자료구조로 가장 마지막에 들어간 값이 먼저 나오게 된다.
문자열에서 문자를 앞에서부터 하나씩 검사하면서 여는 괄호이면 스택에 넣고 닫는 괄호이면
스택에서 값을 하나씩 빼면서 검사할 수 있다.

정상적인 괄호일 경우 여는 괄호가 먼저 나온 다음에 닫는 괄호가 나중에 나오기 때문에
LIFO 방식의 스택에서는 닫는 괄호를 검사할 때 마다 항상 스택에 여는 괄호가
존재하게 되고 검사가 끝난 후엔 스택이 비게 된다.

하지만 정상적인 괄호가 아닐 경우, 구체적으로는
1) 여는 괄호보다 닫는 괄호가 먼저 나왔을 경우 - 예 : if((i==0)))&&((j==0)
전체 괄호의 수는 맞지만 여는 괄호가 두 개 밖에 나오지 않았는데 세 번째 닫는 괄호가
먼저 나왔기 때문에 세 번째 닫는 괄호를 검사할 때 스택이 비어있게 되어 비정상적인
괄호라는 것을 스택을 이용해 판단할 수 있다.
2) 전체 괄호의 수가 맞지 않는 경우 - 예 : if((i==0)&&(j==0)
여는 괄호보다 닫는 괄호의 수가 적어 닫는 괄호를 두 번 검사한 후 검사가 끝났는데도
스택에 여는 괄호가 남아있게 되어 비정상적인 괄호라는 것을 스택을 이용해 판단할 수 있다.


(2) 위의 문자열을 스택을 이용해 검사하는 과정에 대해, 나머지 단계의 스택 내부 상태를 표시하고
간단히 설명하라. 마지막에는 괄호가 정상인지 오류인지와 그 이유를 설명해야 한다.
스택은 []로 표시하고, 저장 원소의 구분은 쉼표나 빈 칸으로 표시한다.

[(] # 여는 괄호를 만나 push
[(, (] # 여는 괄호를 만나 push
[(] # 닫는 괄호를 만나 pop
[(, (] # 여는 괄호를 만나 push
[(] # 닫는 괄호를 만나 pop
[] # 닫는 괄호를 만나 pop
[] # 닫는 괄호를 만나 pop - Error!

마지막 검사에서 닫는 괄호를 만나 스택에서 pop을 해야하는데 이미 스택이 비어있으므로
앞쪽의 여는 괄호 수 보다 현재까지 나온 닫는 괄호의 수가 많다는 것을 알 수 있으므로
괄호가 오류라는 것을 판단할 수 있다.