T = int(input())        # 테스트 케이스의 수 입력 받음
for t in range(1, T+1): # 테스트 케이스의 수 만큼 코드 실행
    N = int(input())    # 영역의 크기 입력 받음

    # 조건1 - NxN개의 구역에 대한 높이 정보가 주어진다.
    hi = [list(map(int, input().split())) for _ in range(N)] # 영역의 높이를 배열에 저장

    # 조건2 - 한 구역을 중심으로, 주변 8개 구역보다 높으면 봉우리 이다.
    # dir : 한 지점을 기준으로 탐색할 8방향의 좌표
    dir = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]

    # ans : 봉우리의 높이를 저장할 배열
    ans = []

    # 조건3 - 가장자리 구역은 봉우리인지 판단할 수 없다.
    for i in range(1, N-1): # 가장자리는 빼고 1부터 N-1까지 탐색
        for j in range(1, N-1): # 가장자리는 빼고 1부터 N-1까지 탐색
            for y, x in dir:    # 한 구역을 중심으로 8방향 탐색
                if hi[i][j] <= hi[i+y][j+x]: # 주변에 현재 구역보다 높거나 같은 영역 있으면 반복문 탈출
                    break
            else: # 반복문을 모두 돌았다면 주변에 현재보다 높거나 같은 영역이 없다는 뜻이므로 봉우리의 높이 추가
                ans.append(hi[i][j])

    # 조건4 - 만약 봉우리가 하나만 있거나 없는 경우, 높이 차는 -1로 표시한다.
    if len(ans) < 2: # 봉우리의 개수가 1개 이하인 경우
        print(f'#{t} -1')
    else: # 봉우리가 2개 이상 존재하는 경우
        ans.sort() # 봉우리의 높이를 순서대로 정렬
        result = ans[-1] - ans[0] # 가장 높은 봉우리에서 가장 낮은 봉우리의 높이 차를 계싼
        print(f'#{t} {result}')